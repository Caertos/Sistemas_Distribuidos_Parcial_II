Capas de acceso definidas por roles de usuario

(IMPORTANTE AHORA EN ESTA ETAPA!!!)
Antes de seguir haciendo las demás capas, se debe crear un backend de login y probar
que funciona y que se accede a cada endpoint o accion dependiendo al JWT y rol de usuario

1) Capa Administrativa (Admin)
- ✔ Gestión de usuarios: crear, editar, eliminar, asignar roles y permisos.
	Implementado: Rutas `/api/admin/users*` en `backend/src/routes/admin.py`; controlador `backend/src/controllers/admin_users.py`.
- ✔ Gestión de configuración e infraestructura: desplegar/detener servicios, reconstruir imágenes, actualizar ConfigMaps/Secrets.
	Implementado: Endpoints `/api/admin/infra/*` (`backend/src/routes/admin.py`) y servicios en `backend/src/services/admin_infra.py` (stubs seguros).
- ✔ Operaciones de base de datos: migraciones, backups/restores, mantenimiento.
	Implementado: Endpoints `/api/admin/db/*` y servicios en `backend/src/services/admin_db.py` (acciones marcadas como `not_executed` / stubs).
- ✔ Monitorización y logs: ver métricas, logs y auditorías.
	Implementado: Endpoints `/api/admin/monitor/*` en `backend/src/routes/admin.py`.
- Interacciones típicas: endpoints de administración, paneles de control, acciones CRUD sobre recursos administrativos.

2) Capa Auditoría (Auditor)
- Gestión de auditoría / acceso de solo lectura a historiales e informes.
	Implementado: En progreso — se ha añadido soporte inicial para el role `auditor` y se han abierto los endpoints de monitorización/auditoría (`/api/admin/monitor/*`) para roles `admin` y `auditor` en modo lectura (GET). Quedan pendientes:
	- Añadir control fino para export (CSV/PDF) y límites de datos (separar consultas clínicas privadas).
	- Tests unitarios/integración que verifiquen que `auditor` tiene solo acceso de lectura y no puede ejecutar operaciones de escritura.
- Acceso de solo lectura a historiales clínicos y metadatos relevantes para auditoría.
- Generación de informes y extracción de datos para cumplimiento y revisiones.
- Revisión de logs de acceso y cambios (who/what/when).
- Interacciones típicas: consultas SQL/lectura de recursos FHIR, generación de CSV/PDF con evidencia.

3) Capa Profesional / Médico (Practitioner)
- Acceso y CRUD clínico (Paciente, Encuentro, Observación, Medicamento).
	Implementado: Parcial — no hay endpoints clínicos implementados; sólo existen `auth`, `secure` y `admin`.
	Nota: Se propone crear un skeleton de rutas/controladores y los permisos necesarios para cubrir las operaciones clínicas básicas.
- Acceso a historias clínicas de pacientes asignados o autorizados.
- Crear/editar encuentros clínicos, diagnósticos, órdenes y prescripciones.
- Registrar observaciones, resultados de pruebas y signos vitales.
- Consultar alertas clínicas, interconsultas y liberar documentos clínicos.
- Interacciones típicas: CRUD sobre recursos clínicos (Paciente, Encuentro, Observación, Medicamento), firmar o validar documentos.

- Observación importante: Las citas apartadas por pacientes deben pasar por un admissioner que acepte o rechace dichas citas; sólo las citas aceptadas por el admissioner deberán ser visibles para usuarios con role `practitioner`. Esto requiere integración entre los endpoints de citas y el workflow de admisión (flag/estado `admitted` o similar).

- Próximos pasos concretos:
	1) Crear skeleton de rutas en `backend/src/routes/practitioner.py` y controladores en `backend/src/controllers/practitioner.py` (stubs retornando 501/Not Implemented o datos de ejemplo).
	2) Añadir role `practitioner` y dependencias de permisos en `backend/src/auth/roles.py` y `backend/src/auth/permissions.py`.
	3) Implementar la regla de visibilidad de citas: sólo citas con estado aceptado/admitidas deben listarse para `practitioner`.
	4) Añadir tests unitarios y de permisos (happy path + caso de citas no admitidas no visibles).
	5) Posteriormente, implementar endpoints clínicos completos y E2E contra una BD seed.

4) Capa Admisión / Enfermería (Admission)
- Registro de datos demográficos, gestión de citas, signos vitales y notas de enfermería.
	Implementado: No — faltan endpoints.
- Registrar y actualizar datos demográficos de pacientes (altas, contacto, identificaciones).
- Gestionar citas, admisiones y derivaciones.
- Medir y registrar signos vitales, alergias, administración de medicamentos y notas de enfermería.
- Interacciones típicas: formularios de admisión, workflows de triage, creación de recursos mínimos de paciente y citas.
- Cada cita no será reflejada a los medicos si no son admitidas.

5) Capa Paciente (Paciente)
- Objetivo: acceso a propios datos, solicitar citas, descargar resúmenes, ver medicaciones y alergias.
-- Estado: PARCIAL (varias funcionalidades implementadas y verificadas; quedan pruebas E2E y ajustes menores).

 - Implementado (verificado en el código):
 	- Autenticación y claims
 		- JWT + refresh; claim `documento_id` presente. Archivos: `backend/src/auth/jwt.py`, `backend/src/auth/refresh.py`.
 		- Middleware de autenticación que inyecta `request.state.user`: `backend/src/middleware/auth.py`.

 	- Endpoints de lectura y export
 		- GET `/api/patient/me` -> `backend/src/routes/patient.py:get_my_profile` (fallback a partir del token si no hay `User` en BD).
 		- GET `/api/patient/me/summary` -> `backend/src/routes/patient.py:get_my_summary` (usa `src/controllers/patient.get_patient_summary_from_model`).
 		- GET `/api/patient/me/summary/export?format=pdf|fhir` -> `backend/src/controllers/patient.generate_patient_summary_export` (export PDF usando ReportLab y Bundle FHIR JSON).
 		- GET `/api/patient/me/appointments` -> `backend/src/routes/patient.py:get_my_appointments` (paginación y filtro `estado`).
 		- GET `/api/patient/me/appointments/{appointment_id}` -> `backend/src/routes/patient.py:get_my_appointment_detail`.
 		- GET `/api/patient/me/encounters/{encounter_id}` -> `backend/src/routes/patient.py:get_my_encounter`.

 	- Mutaciones de citas (implementadas y con reglas de negocio)
 		- POST `/api/patient/me/appointments` -> `backend/src/controllers/patient.create_patient_appointment` (incluye `documento_id` para cumplir constraints Citus; valida disponibilidad y retorna 409 en conflicto).
 		- PATCH `/api/patient/me/appointments/{id}` -> `backend/src/controllers/patient.update_patient_appointment` (actualización parcial con RETURNING).
 		- DELETE `/api/patient/me/appointments/{id}` -> `backend/src/controllers/patient.cancel_patient_appointment` (soft-cancel, `estado='cancelada'`; aplica política de ventana mínima de cancelación).

 	- Reglas de negocio
 		- `is_timeslot_available` y `can_cancel_appointment` implementadas en `backend/src/controllers/patient.py` (evitan solapamientos y aplican la ventana mínima de cancelación).
 		- Se evita considerar citas con estado `cancelada` como conflicto.

 	- Schemas y modelos relevantes
 		- `backend/src/schemas/` contiene `PatientOut`, `PatientSummaryOut`, `AppointmentOut`, `EncounterOut`.
 		- `MedicationOut` y `AllergyOut` han sido enriquecidos con campos opcionales (`inicio`, `fin`, `via`, `prescriptor`, `estado`, `reacciones`, `onset`, `resolved_at`, `clinical_status`) y validadores que normalizan datetimes a UTC.
 		- `backend/src/models/user.py` incluye `fhir_patient_id` que enlaza `User` ↔ paciente (clave para que las consultas devuelvan datos cuando está poblado).

 	- Medicaciones / Alergias
 		- GET `/api/patient/me/medications` y GET `/api/patient/me/allergies` implementados: los controladores intentan consultas enriquecidas y caen a consultas mínimas si las columnas no existen; devuelven estructuras con campos opcionales cuando están disponibles.

 	- Permisos
 		- Se añadió protección para evitar que usuarios con rol `patient` modifiquen historias clínicas o recursos que no les correspondan (dependencias/chequeos en `backend/src/auth/permissions.py` y middleware).

 	- Tests
 		- Tests unitarios/locales para la capa paciente: ubicados en `backend/tests_patient/` (cubren mutaciones, medicaciones/alergias, export y endpoints de lectura). Se ejecutaron localmente y pasan.

 - Pendiente / Falta por implementar (específico de la capa Paciente):
 	- Pruebas end-to-end completas contra una BD seedada (opcional, de integración). Hay seed y scripts en `postgres-citus/init/` y `k8s/1-CitusSql/populate_db_k8s.sh` listos, pero no se ha automatizado un E2E reproducible dentro del repo.
 	- Revisión/ajuste final de comparaciones DB aware/naive si la base de datos devuelve timestamps sin zona; esto está en la lista de subtareas timezone-aware.

- Observaciones operativas importantes (recordatorio):
	- Las consultas clínico-administrativas se basan en que `User.fhir_patient_id` esté poblado; si está vacío, los endpoints devolverán listas vacías (comportamiento intencional).
	- Las consultas usan SQL textual (`text()`), lo que facilita integración con el esquema actual pero requiere cuidado con tipos y compatibilidad cuando se use Citus/Postgres.
	- Para pruebas repetibles en CI es necesario seed/fixtures que creen `User` con `fhir_patient_id` y algunas filas en `cita`/`encuentro`; el workflow de Actions puede ejecutar scripts SQL si se habilita.

- Observaciones operativas importantes:
	- Las consultas clínico-administrativas se basan en que `User.fhir_patient_id` esté poblado; si está vacío, los endpoints devolverán listas vacías (comportamiento intencional).
	- Las consultas usan SQL textual (`text()`), lo que facilita integración con el esquema actual pero requiere cuidado con tipos y compatibilidad cuando se use Citus/Postgres.
	- Para pruebas repetibles en CI es necesario seed/fixtures que creen `User` con `fhir_patient_id` y algunas filas en `cita`/`encuentro`; el workflow de Actions ejecuta scripts SQL si están en `postgres-citus/init/`.

- Recomendaciones / próximos pasos sugeridos (rápido):

 - Recomendaciones / próximos pasos sugeridos (rápido):
 	1) Completar mutaciones de citas: implementar cancelación, actualización de estado y validaciones (POST/PUT/DELETE) y tests asociados. Nota: el endpoint POST mínimo ya fue añadido y verificado end-to-end.
 	2) Mantener y usar fixtures/seed SQL en CI: ya existe `postgres-citus/init/05-seed-patient-example.sql` y el script `k8s/1-CitusSql/populate_db_k8s.sh` fue actualizado para crear el seed determinista.
 	3) Implementar endpoints de lectura de medicaciones/allergies como GETs (si las tablas existen) o como stubs iniciales hasta modelado completo.
 	4) Diseñar, en una tarea separada, la exportación a PDF/serialización y el control fino de consentimientos (revisión legal y auditoría).

	Estas recomendaciones pueden priorizarse; si quieres empiezo ahora con la 1) y creo el skeleton + tests básicos.

Notas generales:
- Principio de menor privilegio: cada capa debe tener acceso mínimo necesario para sus funciones.
- Autorización y autenticación: todas las interacciones deben pasar por el sistema de roles y tokens (JWT/refresh), y quedar registradas para auditoría.
	- ✔ Autenticación y autorización básica implementada: middleware `backend/src/middleware/auth.py` valida JWT, añade `request.state.user` con `role`, y la dependencia `require_role` en `backend/src/auth/roles.py` permite proteger rutas por role.
	- Parcial: el sistema de roles existe (`user_type` en `User`, claim `role` en token). En la práctica se usa `admin` para protección; faltan endpoints/mapeos explícitos para `auditor`, `practitioner`, `admission`, `patient`.
