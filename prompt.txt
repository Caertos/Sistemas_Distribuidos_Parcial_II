Implementar: "Incluir el claim documento_id en el access token JWT emitido por el backend"

Antes de implementar, crean un nuevo branch llamado "experimental"

Objetivo
- Modificar la emisión de access tokens para que incluyan un claim llamado "documento_id" (valor: user.fhir_patient_id o la identidad adecuada) de forma fiable, y asegurar que la rotación/refresh token preserve ese claim. Esto permite que middleware y endpoints FHIR determinen la clave de distribución (Citus) sin ambigüedad.

Resumen de cambios requeridos (archivos)
1. backend/src/routes/auth.py
   - En la función token() añadir "documento_id" a los extras que se pasan a create_access_token.
   - En refresh_token(), pasar "documento_id" al recrear el access token.
2. backend/src/auth/jwt.py (o donde esté create_access_token)
   - Asegurar que create_access_token acepta un parámetro extras: dict y los incluye en el payload final (claims), sin sobrescribir sub/exp/iats estándar.
   - Confirmar que la librería usada para firmar el JWT (p.ej. python-jose) codifica correctamente los claims adicionales.
3. (Opcional) tests/test_auth_documento_claim.py
   - Agregar test unitario/integración que obtenga token y verifique que el claim documento_id existe y tiene el valor esperado.

Implementación técnica (código sugerido — adaptar nombres de imports/paths si difieren)

1) Cambios en backend/src/routes/auth.py (fragmento relevante)
- Reemplaza las líneas donde se crean los extras antes de create_access_token por:

# antes
# extras = {"role": user.user_type}

# después (ejemplo)
extras = {
    "role": user.user_type,
    # usar fhir_patient_id si existe; si no, dejar None o usar fhir_practitioner_id según contexto
    "documento_id": user.fhir_patient_id or user.fhir_practitioner_id or None
}

access_token = create_access_token(subject=user.id, extras=extras)

- En refresh_token(), cuando se crea el nuevo access:

# antes
# access = create_access_token(subject=user.id, extras={"role": user.user_type})

# después
access = create_access_token(subject=user.id, extras={"role": user.user_type, "documento_id": user.fhir_patient_id or user.fhir_practitioner_id or None})

Notas:
- Si user.fhir_patient_id puede ser NULL/None, asegúrate de la política: si documento_id es obligatorio para operaciones FHIR, rechazar tokens sin documento_id o tomar otra acción. Para minimizar ruptura, agrega valor None explícito y deja la verificación a middleware.

2) Cambios en backend/src/auth/jwt.py (create_access_token)
- Asegúrate que la firma del JWT incorpora extras. Ejemplo conceptual (adaptar a la librería que uses):

from datetime import datetime, timedelta
from jose import jwt
from src.config import settings  # asume settings.SECRET_KEY, settings.ALGORITHM, settings.ACCESS_TOKEN_EXPIRE_MINUTES

def create_access_token(subject: str, expires_delta: Optional[timedelta] = None, extras: dict | None = None) -> str:
    now = datetime.utcnow()
    expire = now + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {
        "sub": str(subject),
        "iat": now,
        "exp": expire,
    }
    if extras:
        # mezclar extras sin sobrescribir sub/exp/iat si alguien intenta
        for k, v in extras.items():
            if k in ("sub", "exp", "iat"):
                continue
            payload[k] = v
    token = jwt.encode(payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return token

- Verifica que el create_access_token actual ya soporta extras; si no, implementa el patrón anterior.

3) Test automatizado (pytest) — tests/test_auth_documento_claim.py (ejemplo)
- Instalar dependencias si no están: pytest, httpx, python-jose (si lo usas).
- Test (concepto):

import pytest
from fastapi.testclient import TestClient
from src.main import app
from jose import jwt
from src.config import settings

client = TestClient(app)

def test_token_contains_documento_id(tmp_user):  # tmp_user fixture crea user con fhir_patient_id='12345'
    data = {"username": tmp_user.username, "password": "secret"}  # ajustar según fixture
    resp = client.post("/api/auth/token", data=data)
    assert resp.status_code == 200
    token = resp.json()["access_token"]
    payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
    assert "documento_id" in payload
    assert payload["documento_id"] == tmp_user.fhir_patient_id

- Implementa fixture tmp_user o usa un usuario existente en la BD de pruebas.

Prueba manual rápida (curl)
- Obtener token (OAuth2 password flow):

curl -X POST "http://localhost:8000/api/auth/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=paciente1&password=tu_password"

- Decodificar JWT (local): usar jwt.decode en Python o pegar token en jwt.io. Verifica payload incluye "documento_id".

Validaciones y control de calidad
- Asegurar que create_access_token no exponga PII sensible: documento_id puede ser identificador nacional; confirmar política de privacidad antes de incluirlo en JWT de corta duración. Si es PII sensible y token viaja en clientes inseguros, considerar hash(documento_id) o un identificador interno no reversible.
- Asegurar que la longitud del claim no exceda límites prácticos.
- Confirmar que refresh flow preserva el claim (ya indicado).
- Actualizar doc/openapi si quieres documentar que token contiene documento_id.
- Revisar código que decodifica tokens (auth middleware) y actualizar para usar claim "documento_id" (si aún lee fhir_patient_id desde DB, cambiarlo para leer del token cuando esté presente).

Rollback mínimo
- Si introducir documento_id rompe algo en producción: revertir commit que cambia auth.py y jwt.py; mantener versión anterior de tokens; invalidar tokens emitidos después del deploy por rotación de secret (si necesario).

Commit / PR recomendados
- Título PR: "auth: incluir claim documento_id en access token JWT"
- Descripción PR (breve):
  - Añade claim documento_id a access tokens (valor user.fhir_patient_id o user.fhir_practitioner_id si aplica).
  - Ajusta flujo de refresh para preservar documento_id.
  - Añade test que verifica presencia del claim.
  - Motivo: facilitar autorización y enrutamiento de operaciones FHIR hacia la BD distribuida (clave de distribución Citus).
- Checklist en PR:
  - [ ] Tests unitarios pasan
  - [ ] Manual curl -> token -> jwt.io: document_id presente
  - [ ] Middleware/consumers que usan documento_id actualizados o revisados
  - [ ] Documentación interna actualizada

Consideraciones de seguridad y privacidad (obligatorias, breves)
- Riesgo: poner identificador personal en JWT que viaja a cliente. Mitigaciones:
  - Mantener access token con short TTL (p. ej. 15 min) y usar refresh tokens opacos (ya existen).
  - Considerar enviar en token solo un identificador interno no correlacionable con un documento personal (hash salado) si la ley/privacidad lo exige.
  - Registrar en auditoría cualquier acceso donde se use documento_id.
- No incluir otros datos sensibles en el payload.

Despliegue y verificación
1. Crear branch: feature/add-documento-claim-jwt
2. Implementar cambios y tests localmente.
3. Ejecutar test suite: pytest
4. Levantar backend local y hacer pruebas manuales con curl.
5. Abrir PR y solicitar revisión de 1 miembro del equipo (revisor sugerido: administrador/owner).
6. Merge y deploy a staging; verificar logs y tráfico JWT.

Mensaje final mínimo para pegado en tarea/issue
- Tarea: incluir document_id en access JWT.
- Archivos a tocar: backend/src/routes/auth.py, backend/src/auth/jwt.py.
- Pruebas: tests/test_auth_documento_claim.py + curl manual.
- Riesgo principal: privacidad (evaluar uso de hash / TTL corto).

Por ultimo, hacer comprobacion con tests, y hacer un .md con documentación unicamente de resultados

sí pasa todos los tests y dicha impletación funciona entonces podemos hacer el pull request.